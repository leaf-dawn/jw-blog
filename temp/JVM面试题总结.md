---
title: JVM面试题总结
date: 2023-01-03 17:09:04
theme: cyanosis
highlight: atom-one-dark-reasonable
tags:
 - jvm
 - java
 - 面试
categories:
 - jvm
cover: https://img.fansqz.com/img/195425_86576174661.jpg
---
# JVM面试题总结
## 基本了解

### JDK、JRE、JVM的区别

JDK：开发环境

JRE：运行环境

JVM：Java虚拟机

### 说下JVM的组成？

- 类加载器
- 执行引擎
- 本地接口
- 运行时数据区

首先，程序员变成好java文件，通过编译器编译成.class文件。.class文件通过类加载器加载到JVM的运行时数据区中。由执行引擎解释执行。执行引擎读取字节码指令，将字节码指令翻译器机器指令，再交由CPU去执行



## 运行时数据区

### 说下运行时数据区内容，分别有什么作用？

1. 程序计数器：用于存储指向下一条JVM指令地址
2. 虚拟机栈：**每个线程在创建时都会创建一个独立的虚拟机栈，其内部保存着一个个的栈帧（Stack Frame），对应着一次次的Java方法调用**
3. 本地方法栈：主要用于管理本地方法的调用
4. 堆：用于存放对象
5. 方法区：用于存储**类型信息，运行时常量池，静态变量，JIT代码缓存，域信息，方法信息**

### 栈需要指向堆吗？如果要，栈如何指向堆？

栈需要指向堆，因为非静态方法可以通过this.使用对象的属性。

如果是非静态方法，在栈中的局部变量表的第一个元素会存储this的指针，指向堆中的对象。

### 为什么要有pc寄存器？

cpu需要不停切换各个线程，这时候却换回来以后，就得直到接着要从哪里继续执行。所以需要借助pc寄存器来确定一条应该执行什么字节码指令

### pc寄存器为什么要设置为线程私有？

答：了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的方法自然是为每一个线程分配一个pc寄存器

## 垃圾回收

### 什么时候出发Full GC

1. 调用System.gc();
2. 老年代空间不足。
3. 空间分配担保失败。
4. JDK 1.7 及以前的**永久代**内存不足
5. CMS 由于浮动垃圾导致并发失败。

### GCRoot有哪些？

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象
5. 所有被同步锁synchronized持有的对象
6. ...

### java会存在内存泄漏吗？

java会存在内存溢出问题，虽然说java有垃圾回收机制。但是如果有些垃圾对象一直被其他对象所引用的话，是无法被GC回收的。

## 类加载过程

### 什么是双亲委派机制？

答：双亲委派机制是指一个类在收到类加载请求后不会尝试自己加载这个类，而是把该类加载请求向上委派给其父类加载器去完成，其父类加载器在接收到该类加载请求后又会将其委派给自己的父类，以此类推，这样所有的类加载请求都被向上委派到启动类加载器中。

### 如何打破双亲委派机制？

答：打破双亲委派机制则不仅**要继承ClassLoader**类，还要**重写loadClass和findClass**方法。



## java对象的创建过程

### java对象的创建过程时怎么样的？

1. **判断对象对应的类是否加载、链接、初始化**
2. **为对象分配内存**
   - 如果内存规整：指针碰撞
   - 如果内存不规整：空闲列表分配
3. **处理并发安全问题**
   - 采用CAS配上失败重试保证更新的原子性
   - 每个线程预先分配一块TLAB
4. **初始化分配到的空间**： 所有属性设置默认值
5. **设置对象的对象头**
6. **执行`<init>`方法进行初始化**
   - 显示初始化
   - 代码块初始化
   - 构造器中初始化

### 对象的内存分布是怎么样的？

对象在内存中一共有三个部分：

1. 对象头
   - 运行时元数据
   - 类型指针：指向方法区中的对象具体类型
2. 实例数据
3. 对其填充

### 对象一定分配在堆中吗？有没有了解逃逸分析计数？

答：不一定的，JVM通过「逃逸分析」，那些逃不出方法的对象会在栈上分配。

**逃逸分析：**判断一个对象的引用范围是否局限于本地。

通过逃逸分析发现一个对象不会被外部引用，则可以实现一些优化：

1. 栈上分配。
2. 同步消除。如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步
3. 标量替换。把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有，一、减少内存使用，因为**不用生成对象头**。二、程序内存回收效率高，并且GC频率也会减少。

### 数组在堆中创建还是在栈上创建？

答：在Java中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。